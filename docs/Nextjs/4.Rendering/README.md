# 렌더링

렌더링은 작성한 코드를 사용자 인터페이스로 변환합니다. React와 Next.js는 서버 또는 클라이언트에서 코드 일부를 렌더링할 수 있는 하이브리드 웹 애플리케이션을 만들 수 있게 합니다. 이 섹션은 이러한 렌더링 환경, 전략 및 런타임의 차이를 이해하는 데 도움을 줄 것입니다.

## 기본 개념

먼저, 세 가지 웹 개념을 이해하는 것이 도움이 됩니다:

1. 애플리케이션 코드가 실행될 수 있는 환경: 서버 및 클라이언트.
2. 사용자가 애플리케이션을 방문하거나 상호작용할 때 시작되는 요청-응답 라이프사이클.
3. 서버 및 클라이언트 코드를 분리하는 네트워크 경계.

## 렌더링 환경

웹 애플리케이션을 렌더링할 수 있는 두 가지 환경이 있습니다: 클라이언트와 서버.

<img src="https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Fclient-and-server-environments.png&w=3840&q=75&dpl=dpl_7ApAXAPS9Jx2rHVsnwoDNiDWWrWe">

### 클라이언트 및 서버 환경

-   클라이언트는 사용자 장치의 브라우저를 나타내며 애플리케이션 코드를 서버에 요청한 후 서버의 응답을 사용자 인터페이스로 변환합니다.
-   서버는 데이터 센터의 컴퓨터를 나타내며 애플리케이션 코드를 저장하고 클라이언트로부터 요청을 받아 적절한 응답을 보냅니다.

과거에는 개발자가 서버 및 클라이언트에 코드를 작성할 때 서로 다른 언어 (예: JavaScript, PHP) 및 프레임워크를 사용해야 했습니다. React를 사용하면 동일한 언어 (JavaScript) 및 동일한 프레임워크 (예: Next.js 또는 선택한 프레임워크)를 사용할 수 있어, 이러한 유연성 덕분에 컨텍스트 전환이 필요 없이 두 환경 모두에 코드를 쉽게 작성할 수 있습니다.

그러나 각 환경에는 고유한 능력과 제약이 있습니다. 따라서 서버 및 클라이언트에 작성하는 코드가 항상 동일하지는 않습니다. 특정 작업 (예: 데이터 가져오기 또는 사용자 상태 관리)은 한 환경에서 다른 환경보다 더 적합합니다.

이러한 차이를 이해하는 것은 React와 Next.js를 효과적으로 사용하는 핵심입니다. 우리는 서버 및 클라이언트 구성 요소 페이지에서 더 자세히 차이점과 사용 사례를 다룰 것이지만, 일단 기초를 계속해 봅시다.

## 요청-응답 라이프사이클

대체로 모든 웹 사이트는 동일한 요청-응답 라이프사이클을 따릅니다:

1. 사용자 동작: 사용자가 웹 애플리케이션과 상호작용합니다. 이는 링크를 클릭하거나 양식을 제출하거나 브라우저 주소 표시줄에 직접 URL을 입력하는 것일 수 있습니다.
2. HTTP 요청: 클라이언트가 서버에 필요한 리소스 및 사용되는 메서드 (예: GET, POST) 및 필요한 경우 추가 데이터에 대한 정보를 포함한 [HTTP](https://developer.mozilla.org/ko/docs/Web/HTTP) 요청을 보냅니다.
3. 서버: 서버는 요청을 처리하고 적절한 리소스로 응답합니다. 이 프로세스에는 경로 지정, 데이터 가져오기 등 여러 단계가 포함될 수 있습니다.
4. HTTP 응답: 요청 처리 후, 서버는 클라이언트에 HTTP 응답을 보냅니다. 이 응답에는 요청이 성공했는지 여부를 클라이언트에 알려주는 상태 코드 및 요청된 리소스 (예: HTML, CSS, JavaScript, 정적 자산 등)가 포함됩니다.
5. 클라이언트: 클라이언트는 리소스를 구문 분석하여 사용자 인터페이스를 렌더링합니다.
6. 사용자 동작: 사용자 인터페이스가 렌더링되면 사용자가 상호작용할 수 있으며 전체 프로세스가 다시 시작됩니다.

하이브리드 웹 애플리케이션을 구축하는 주요 부분은 라이프사이클의 작업을 어떻게 분할하고 네트워크 경계를 어디에 둘지 결정하는 것입니다.

## 네트워크 경계

웹 개발에서 네트워크 경계(Network Boundary)는 서로 다른 환경을 분리하는 개념적인 선입니다. 예를 들어, 클라이언트와 서버, 또는 서버와 데이터 저장소 등을 분리합니다.

React에서는 클라이언트-서버 네트워크 경계를 어디에 놓을지를 선택할 수 있습니다. 내부에서 작업은 클라이언트 모듈 그래프와 서버 모듈 그래프로 분할됩니다. 서버 모듈 그래프에는 서버에서 렌더링되는 모든 구성 요소가 포함되며 클라이언트 모듈 그래프에는 클라이언트에서 렌더링되는 모든 구성 요소가 포함됩니다.

모듈 그래프는 애플리케이션의 파일이 서로 어떻게 의존하는지를 시각적으로 나타낸 것으로 생각할 수 있습니다. React에서는 네트워크 경계를 정의하기 위해 "use client" 규칙을 사용할 수 있습니다. 또한 "use server" 규칙을 사용하여 클라이언트와 서버에서 각각 어떤 계산 작업을 수행할지 지정할 수 있습니다.

## 하이브리드 애플리케이션 구축

이러한 환경에서 작업할 때 애플리케이션 코드의 흐름을 단방향으로 생각하는 것이 도움이 됩니다. 다시 말해, 응답 중에 애플리케이션 코드는 서버에서 클라이언트로 한 방향으로 흐릅니다.

클라이언트에서 서버에 액세스해야 하는 경우, 동일한 요청을 재사용하는 대신 서버에 새로운 요청을 보냅니다. 이렇게 하면 구성 요소를 어디에 렌더링해야 하는지와 네트워크 경계를 어디에 놓아야 하는지 이해하기가 더 쉬워집니다.

실제로 이 모델은 개발자가 서버에서 먼저 무엇을 실행하고 클라이언트로 결과를 보내서 애플리케이션을 상호작용 가능하게 하는 방식에 대해 생각하도록 유도합니다.

이 개념은 동일한 컴포넌트 트리에서 클라이언트 및 서버 구성 요소를 어떻게 교차로 배치할 수 있는지 살펴볼 때 더 명확해집니다.
