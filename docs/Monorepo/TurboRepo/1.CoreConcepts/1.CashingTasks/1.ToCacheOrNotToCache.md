## 캐시 여부 결정하기

Monorepo를 구축할 때 이전에 실행한 작업을 기반으로 해당 작업을 건너뛸 수 있는지를 개별 작업 단위로 결정해야 합니다. 이 동작은 turbo.json 내의 `pipeline.<task>.cache`를 통해 제어됩니다.

/turbo.json

```json
{
    "$schema": "https://turbo.build/schema.json",
    "pipeline": {
        "lint": {
            "cache": true
        }
    }
}
```

Turborepo는 기본적으로 "cache": true로 설정되어 있으므로 이 값을 명시할 필요가 없습니다. 따라서 이것은 동일한 구성입니다.

/turbo.json

```json
{
    "$schema": "https://turbo.build/schema.json",
    "pipeline": {
        "lint": {}
    }
}
```

이 예에서는 Turborepo에게 lint 작업을 캐시하도록 지시했습니다. 그러나 캐시 키만 지정했기 때문에 캐시되는 것은 터미널 출력뿐입니다. lint 또는 test와 같은 일부 유형의 작업의 경우 이러한 최소 구성이 올바르다고 볼 수 있습니다!

그러나 대부분의 작업의 경우 캐시가 유효한 경우 캐시해야 할 파일 및 환경 변수를 지정해야 합니다.

캐시하지 않아야 하는 경우
"cache": false는 "항상 실행!"이 아니라 "이 작업이 실행되려면 캐시에서 복원되지 않을 것"을 의미합니다. "cache": false를 사용하여 배포와 같은 부작용을 트리거하지 마십시오.

캐싱이 기본 동작이며 대부분의 상황에 이상적이므로 이 동작에서 벗어나는 시점을 알아내는 것이 중요합니다.

1. 매우 빠르게 실행되는 작업. 원격 캐시를 사용하고 작업이 네트워크 왕복 시간보다 짧게 실행될 수 있다면(예: 100 밀리초 미만), 작업을 캐시하지 않는 것을 고려해야 합니다.
2. 출력 자산이 거대한 작업. 작업 실행의 결과로 Docker Container를 생성하는 경우, 캐시 아티팩트를 생성하고 업로드하며 다운로드하는 시간이 다시 생성하는 데 소요되는 시간을 초과할 수 있습니다.
3. 변환되지 않는 파일 시스템 작업. 작업이 "한 디렉토리에서 다른 디렉토리로 많은 이미지를 이동"하는 경우 작업은 시간이 걸릴 수 있지만 해당 자산을 캐시하고 복원하는 것보다 로컬에서 이동 자산을 처리하는 것이 항상 빠릅니다.
4. 자체 응용 프로그램 동작 인식 캐시를 구현하는 작업. 일부 작업은 Docker의 Layer Cache와 같은 내부 캐싱 동작을 갖고 있습니다. 대부분의 경우 이러한 보조 캐시는 Turborepo와 함께 잘 작동하지만 경우에 따라 구성이 굉장히 복잡해질 수 있습니다.

Turborepo에 대한 더 많은 경험을 쌓으면 이러한 지침 중 일부가 다른 환경에서 실행될 때 예상치 못한 트레이드오프를 가질 수 있음을 발견할 것입니다. 예를 들어, 때로는 CI 서비스에서 디스크 읽기가 네트워크 읽기보다 크게 느릴 수 있습니다. 캐시하지 않는 것이 성능 이점을 제공하는지 여부를 확인하기 위해 프로젝트에서 동작을 테스트하십시오.
